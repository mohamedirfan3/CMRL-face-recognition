import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk, ImageDraw
import subprocess
import cv2

from PIL import Image, ImageTk
import pickle
import numpy as np

# Load face recognition data
with open(r'D:\Downloads\face recognition metroo\data\names.pkl', 'rb') as w:
    LABELS = pickle.load(w)
with open(r'D:\Downloads\face recognition metroo\data\faces_data.pkl', 'rb') as f:
    FACES = pickle.load(f)

# Initialize face recognizer
from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# Initialize global variables
cap = None
camera_active = False

# Function to start and update the camera feed
def start_camera():
    global cap, camera_active
    if not camera_active:
        cap = cv2.VideoCapture(0)
        camera_active = True
        update_camera()

def stop_camera():
    global cap, camera_active
    if camera_active:
        cap.release()
        camera_active = False
        camera_label.config(image='')  # Clear camera feed

# Function to update the camera feed in the interface
def update_camera():
    if camera_active:
        ret, frame = cap.read()
        if ret:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
            faces = facedetect.detectMultiScale(gray, 1.3, 5)
            
            for (x, y, w, h) in faces:
                crop_img = frame[y:y+h, x:x+w]
                resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
                output = knn.predict(resized_img)
                name = output[0]
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
                cv2.putText(frame, name, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)
            
            # Resize the frame to fit the camera_label
            frame = cv2.resize(frame, (camera_label.winfo_width(), camera_label.winfo_height()))
            # Convert the frame to an image that Tkinter can display
            cv2image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(cv2image)
            imgtk = ImageTk.PhotoImage(image=img)
            camera_label.imgtk = imgtk
            camera_label.config(image=imgtk)
        
        # Schedule the next frame update
        camera_label.after(30, update_camera)

# GUI setup (same as in your previous code)
# ...
# Create the main window and other elements (buttons, labels, etc.)
# ...

# Start the camera feed on application startup

# Initialize global variables
cap = None
camera_active = False

# Function to start and update the camera feed
def start_camera():
    global cap, camera_active
    if not camera_active:
        cap = cv2.VideoCapture(0)
        camera_active = True
        update_camera()
 
def stop_camera():
    global cap, camera_active
    if camera_active:
        cap.release()
        camera_active = False
        camera_label.config(image='')  # Clear 
# Function to update the camera feed in the interface
def update_camera():
    if camera_active:
        ret, frame = cap.read()
        if ret:
            # Resize the frame to fit the camera_label
            frame = cv2.resize(frame, (camera_label.winfo_width(), camera_label.winfo_height()))
            # Convert the frame to an image that Tkinter can display
            cv2image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(cv2image)
            imgtk = ImageTk.PhotoImage(image=img)
            camera_label.imgtk = imgtk
            camera_label.config(image=imgtk)
       
        camera_label.after(30, update_camera)  


def run_in_time():
    stop_camera()
    result = subprocess.run(["python", r"D:\Downloads\face recognition metroo\in time.py"], capture_output=True, text=True)
    if result.returncode == 0:
        details = result.stdout.strip()  # Capture the printed output (name, time, date)
        message_label.config(text=details, fg="blue", bg="#f0f0f0")
        root.after(30000, lambda: message_label.config(text=""))
    else:
        message_label.config(text="Error running script", fg="red", bg="#f0f0f0")
    start_camera()

def run_out_time():
    stop_camera()  
    result = subprocess.run(["python", r"D:\Downloads\face recognition metroo\out time attedance"], capture_output=True, text=True)
    if result.returncode == 0:
        detail = result.stdout.strip()  # Capture the printed output (name, time, date)
        message_label.config(text=detail, fg="blue", bg="#f0f0f0")
        root.after(30000, lambda: message_label.config(text=""))
    else:
        message_label.config(text="Error running script", fg="red", bg="#f0f0f0")
    start_camera()
# Function to handle new attendance
def new_attendance():
    try:
        subprocess.run(["python", r"Dataset.py"], check=True)
    except Exception as e:
        message_label.config(text=f"Exception: {str(e)}", fg="red", bg="#f0f0f0")

# Create the main window
root = tk.Tk()
root.title("Attendance System")

# Set the window to fullscreen
root.attributes('-fullscreen', True)
root.bind("<F11>", lambda event: root.attributes('-fullscreen', True))  # Toggle fullscreen with F11
root.bind("<Escape>", lambda event: root.attributes('-fullscreen', False))  # Exit fullscreen with Escape

# Create a Canvas widget for the background image
canvas = tk.Canvas(root, width=root.winfo_screenwidth(), height=root.winfo_screenheight())
canvas.pack(fill=tk.BOTH, expand=True)

# Function to update background, corner image, and watermark
def update_images(event=None):
    # Load and update the background image
    background_image = Image.open(r"D:\Downloads\face recognition metroo\metrol.png")
    background_image = background_image.resize((root.winfo_width(), root.winfo_height()), Image.LANCZOS)
    background_photo = ImageTk.PhotoImage(background_image)
    canvas.create_image(0, 0, anchor=tk.NW, image=background_photo)
    canvas.image = background_photo
    
    # Load and update the corner image
    corner_image = Image.open(r"D:\Downloads\face recognition metroo\new logo.webp")
    corner_image = corner_image.resize((300, 300), Image.LANCZOS)  # Resize image as needed
    corner_photo = ImageTk.PhotoImage(corner_image)
    canvas.create_image(root.winfo_width() - 110, 10, anchor=tk.NE, image=corner_photo)
    canvas.corner_image = corner_photo

    # Add watermark text
    watermark_text = "Designed and Developed by Mohamedirfan CMRL"
    canvas.create_text(root.winfo_width() - 10, root.winfo_height() - 10,
                       anchor=tk.SE,
                       text=watermark_text,
                       fill="white",
                       font=('Helvetica', 10, 'italic'))

root.bind('<Configure>', update_images)
update_images()

# Style for the rounded buttons
style = ttk.Style()
style.configure('Rounded.TButton',
                background='#007bff',  # Button color
                foreground='black',    # Text color
                font=('Helvetica', 14, 'bold'),
                borderwidth=0,         # No border
                relief='flat',         # Flat appearance
                padding=10)

style.map('Rounded.TButton',
          background=[('active', '#0056b3')],  # Color when button is hovered
          foreground=[('active', 'black')])  # Text color when hovered

# Create custom images for rounded buttons if needed
def create_rounded_button_image(width, height, color):
    """Create a rounded button image."""
    image = Image.new('RGBA', (width, height), (0, 0, 0, 0))
    draw = ImageDraw.Draw(image)
    draw.rounded_rectangle([0, 0, width, height], radius=20, fill=color)
    return ImageTk.PhotoImage(image)

button_bg = create_rounded_button_image(150, 50, '#007bff')  # Rounded button image

# Create buttons using the styled ttk.Button
button_width = 150
button_height = 50

in_time_button = ttk.Button(root, text="In Time", style='Rounded.TButton', command=run_in_time)
in_time_button.place(relx=1.0, rely=0.4, anchor=tk.E, x=-150)  # Place button a bit left from the right edge

out_time_button = ttk.Button(root, text="Out Time", style='Rounded.TButton', command=run_out_time)
out_time_button.place(relx=1.0, rely=0.5, anchor=tk.E, x=-150)  # Place button a bit left from the right edge

new_attendance_button = ttk.Button(root, text="New Attendance", style='Rounded.TButton', command=new_attendance)
new_attendance_button.place(relx=1.0, rely=0.6, anchor=tk.E, x=-135)  # Place button a bit left from the right edge

# Create a frame to hold the camera feed, positioned at the bottom right with fixed size
camera_frame_width = 200  # Adjusted width of the camera feed frame
camera_frame_height = 150  # Adjusted height of the camera feed frame
camera_frame = tk.Frame(root, width=camera_frame_width, height=camera_frame_height, bg='black', borderwidth=2, relief='solid')
camera_frame.place(relx=1.0, rely=0.95, anchor=tk.SE, x=-110)  # Positioned at the bottom-right corner

# Label to display the camera feed
camera_label = tk.Label(camera_frame, width=camera_frame_width, height=camera_frame_height)  # Set fixed size for label
camera_label.pack()

# Label to display messages
message_label = tk.Label(root, text="", font=('Helvetica', 20, 'bold'), fg="blue", bg="#f0f0f0")
message_label.place(relx=1.0, rely=0.7, anchor=tk.N ,x=-240)  # Place the message at the top center of the window

# Start the camera feed on application startup
start_camera()

# Start the GUI loop
root.mainloop()
